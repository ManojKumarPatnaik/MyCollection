
- Whenever we create a class or directive we add in app.module
- 
- Content projection is a pattern in which you insert, or project, the content you want to use inside another component
	- Ng-content : 
			- single-slot content projection - most basic
			- users of this component can now project their own message into the component
			- used when we want to insert the content dynamically inside the component that helps to increase component reusability
			- Add a select attribute to the <ng-content> elements
			- Each slot can specify a CSS selector that determines which content goes into that slot. This pattern is referred to as multi-slot content projection.
			- <ng-content select="[question]"></ng-content>
	- Ng-template : 
			- conditionally projection using <ng-template>
- Directives : An instruction to DOM
	- Components : AppComponents
	- Attribute Directives : ngStyle, ngClass
	- Structural : ngIf , ngFor
- Event Bubbling : 
- NgRx : 
	- Subscription : Each subs to observable, its help in memory and if not released creates a memory leak.
- ChangeDetectionStrategy : 
	- OnPush change detection strategy for specific components
	- ... : spread snatx: pass individual entry to the function. 
		- console.log(..."BANANA") - o/p - B A N A N A
		- Math.min(...."5432") : 2 here we are passing each digit individually to the min function
		- combine 2 arrays to 1
			- a["a","b"], b["c","d'], newaRR= [...a,...b] - ["a","b","c","d"] without spread it would have given  a nested array
	- apply changedetection on the child component and it detects changes from the parent 
	- The child component is updated when Angular detects the data has changed in the parent component.
	- this.aquaticCreatures = [...this.aquaticCreatures, newAquaticCreature]; - this is an array that is marking a push intself in the parent component
- NgZone:

--------------------------------------------------------------------------------------------------------------------------------------------------------------

template reference : #primaryinput etc -- starts with #

=> VIEWCHILD
=================
=> NEED
	- Appcomponent need references to many elements inside its template. thats when viewchild can be used
	- Change behaviour of element in component class. Then we must get reference of the element. 
	- It return ElementRef type
	-  sample : 
		> user.component.html
			<span class="" #somecontent> Some Content </span>
		> user.component.ts
			export class LatesComponent implement OnInit{
			@ViewChild('somecontent') somecontent : ElementRef;
	- when parent component are getting constructed means child are not created yet
	- Lifecycle where the viewchild child are created		
			- ngAfterViewInit
			- ngAfterViewChildChecked
		> We need to import  ViewChild, AfterViewInit, ElementRef from @angular/core
			user.component.ts
				export class LatesComponent implement OnInit, AfterViewInit{
				ngAfterViewInit(){
				console.log('Child created here')
				this.somecontent.nativeElemt //this returns the DOM}
=> COMPONENT AS A ViewChild
	- create a new component lets say dateComponent
	> date-viewer.component.ts	
		date: Date = new Date()
	> date-viewer.component.html
		{{date}}
	> user.component.html
		<div>
			<span class="">
				<app-date-viewer></app-date-viewer>
	- inherit in user.component.ts
	> @ViewChild{DateViewComponent} dateViewerComponent : DateViewComponent
		ngAfterViewInit(){
			console.log(this.dateViewerComponent.Today); //dateViewerComponent contains all variables of the DateViewComponent
	- we can also updte DateViewComponent value in UserComponent
=> ViewChildren
	- if we wan to access multiple decorator, then we use it.
	- returns QueryList<> type.
	> user.component.html
		<div>
			<span class="">
				<app-date-viewer></app-date-viewer>
				<app-date-viewer></app-date-viewer>
				<app-date-viewer></app-date-viewer>
	- in above case only once the console.log will print if we user ViewChild.
	- import ViewChildren
	> @ViewChildren{DateViewComponent} dateViewerComponent : QueryList<DateViewComponent>
	ngAfterViewInit(){
			console.log(this.dateViewerComponent.ToArray()); //convert QueryList toArray
			}

--------------------------------------------------------------------------------------------------------------------------------------------------------------
=> DIRECTIVE
===================
	- Modify existing behavior to elements *in template
	- Used to manipulate DOM
	- Types:
		- Component directive-
			-  directive with template
			- shows something in DOM
		- structural directive
			- Change DOM by adding removing DOM element
				- Ex : *ngIf, *ngFor, ngSwitch
		- Attribute Directive
			- Change appearance or behavior
				- EX: ngStyle, ngClass
	- Creating own
		- @Directive decorator
		- ElementRef dependency using constructor
		- Listen to event, listen to DOM event on host element : HostListener
			- Example [Attribute Directive]: Changecolor on hover
				- @Directive({ selectore: '[highlight]' )}
- [ ] Export  class Highlightdirective{
      				Constructor  (private eleRef: ElementRef) {}
      				@HostListener  ('mouseover') onMouseOver()[
      				This.eleRef.nativeElement.style.color  ='red';
      				}
      				@HostListener  ('mouseleave') onMouseOver()[
      				This.eleRef.nativeElement.style.color  ='black';
      				}
	- Passing input to directive
		- Using @input
			- Same name as directive - @Input highlight
				- <p highlight="blue"> Highlight Directive </p>
			- Any variable - @Input() colorName
				- <p highlight="blue" colorName="green"> Highlight Directive </p>
	- Example [structural directive]: adds or remove content based in value provided
		- <div *toggle="true"><p>some text</p></div>
		- @Directive with selector property
		- Structural directive need 2 things and inject in constructor
			1. ViewContainerRef : holds Reference to host element
			2. TemplateRef : holds reference of template defined by ng-template
		- Create @input same as directive , to add remove content
		- ngOnChnages() lifecycle hook : when value is true or false
--------------------------------------------------------------------------------------------------------------------------------------------------------------
=> INTERCEPTORS
===================
@injectable - 
marks class is avaiable to be provided and injected as a dependency

interceptors
-------------
- main purpose is to capture and modify HTTP requests and responses.
- helps in authorization, changing headers, modify resonse from server, caching etc
- Its a TS class iplements HttpInterceptor interface
- intercept() ->  identiifes and handles HTTP requests
> 
export class AuthInterceptorService implements HttpInterceptor {
  constructor(private authService: AuthService) {} 
 intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {  
    const token = this.authService.getAuthToken();

   if (token) {
     // If we have a token, we set it to the header
     request = request.clone({
        setHeaders: {Authorization: `Authorization token ${token}`}
     });
  }

  return next.handle(request).pipe(
  	catchError((err) => {
   	 if (err instanceof HttpErrorResponse) {
       	 if (err.status === 401) {
       	 // redirect user to the logout page
     	}
 	 }
  	return throwError(err);
	})
   )
  }
}

> add the interceptor service to AppModule
	providers: [ Authservice {
							provide : HTTP_INTERCEPTORS
							useClass : AuthInterceptorService
							multi : true // tells angular that we can provide multiple values for a single token in DI
							}//for multi interceptor add ',' after this ofbject and repeat same
							]
--------------------------------------------------------------------------------------------------------------------------							
PIPES
=======
- simple dunctuions to use in template expression to accept an input value and return an transformed value.
> ng new pipes
- syntax : {{input | pipeName}}
		(multi param) - {{ input| pipeName: param1 param2:
	> Date Pipe
	------------
		- export class AppComponent { birthday = new Date(1996, 3 ,21) }
		- My birthday is {{birthday | date}}
		- (multi) : {{ value_expression | date [ : format [ : timezone [ : locale ] ] ] }}
			- {{ birthday | date: 'dd/MM/yyyy' }}
-Types
--------
	- pure  : default , called when Angular detects a change in the passed value
	- impure : called for every change detection cycle no matter whether the value changes
				- add pure:false in the @pipe decorator where we provide the name of the pipe.
- Pipe Chaining
------------------
	- {{ birthday | date: 'fullDate' | uppercase }}
	- pipes applied from left to right
	
- Build - in Pipes
-------------------
	- CurrencyPipe, UpperCasePipe/LowerCasePipe/TitleCasePipe 
	- PercentPipe - input is number to string 
	- DecimalPipe - numer to string

- Custom Pipes
----------------
	> ng g pipes/age
	> age.pipe.ts
	------------SYNTAX--------------
		import {Pipe, PipeTransform} from '@angular/core';
		@Pipe({
			name : 'age' })
		export class AgePipe implements PipeTransform {
			transform( value: any, ...args: any[]): any {
				return null;}
				}
	-------------Ex------------------
	export class AgePipe implements PipeTransform {
		
		transform(value: Date, capitalize: boolean = false, withEmojis: boolean = false): any {
			const currentYear = new Date().getFullYear();
			const dobYear = value.getFullYear();     const age = currentYear - dobYear;
		
			return age + ' years old';
		}}
		
	{{ birthday | age }}
	{{ birthday | age: true: true }}
